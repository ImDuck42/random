{
  "repository_info": {
    "name": "Automation Scripts Hub",
    "version": "2.1.0",
    "description": "Curated collection of cross-platform automation scripts",
    "author": "Automation Community",
    "last_updated": "2024-01-15T12:00:00Z",
    "total_scripts": 25,
    "categories": ["system", "network", "security", "productivity", "development", "utilities"]
  },
  
  "global_variables": {
    "description": "Common variables that can be used across scripts",
    "variables": {
      "COMPANY_NAME": "Acme Corp",
      "BACKUP_PATH": "C:\\Backups",
      "LOG_PATH": "/var/log/automation",
      "ADMIN_EMAIL": "admin@example.com",
      "API_ENDPOINT": "https://api.example.com/v1",
      "TIMEOUT_SECONDS": "30",
      "MAX_RETRIES": "3",
      "DEFAULT_USER": "{{USERNAME}}"
    }
  },
  
  "scripts": [
    {
      "id": "sys-monitor-001",
      "name": "System Health Monitor",
      "description": "Comprehensive system health check with performance metrics",
      "category": "system",
      "platform": "all",
      "requires_admin": false,
      "tags": ["monitoring", "performance", "diagnostics"],
      "version": "1.2.0",
      "author": "SysOps Team",
      "dependencies": [],
      "code": "# System Health Monitoring Script\n# Use {{THRESHOLD_CPU}} and {{THRESHOLD_MEM}} to adjust thresholds\n\n$ErrorActionPreference = 'Stop'\ntry {\n    # CPU Usage\n    $cpu = Get-WmiObject Win32_Processor | Measure-Object -Property LoadPercentage -Average | Select-Object Average\n    Write-Host \"CPU Usage: $($cpu.Average)%\"\n    \n    # Memory Usage\n    $mem = Get-WmiObject Win32_OperatingSystem\n    $totalMem = [math]::Round($mem.TotalVisibleMemorySize/1MB, 2)\n    $freeMem = [math]::Round($mem.FreePhysicalMemory/1MB, 2)\n    $usedMem = $totalMem - $freeMem\n    $memPercent = [math]::Round(($usedMem/$totalMem)*100, 2)\n    Write-Host \"Memory Usage: $memPercent% ($usedMem/$totalMem GB)\"\n    \n    # Disk Space\n    $disks = Get-WmiObject Win32_LogicalDisk -Filter \"DriveType=3\"\n    foreach ($disk in $disks) {\n        $freeGB = [math]::Round($disk.FreeSpace/1GB, 2)\n        $totalGB = [math]::Round($disk.Size/1GB, 2)\n        $usedGB = $totalGB - $freeGB\n        $percentFree = [math]::Round(($freeGB/$totalGB)*100, 2)\n        Write-Host \"Disk $($disk.DeviceID): $percentFree% free ($freeGB/$totalGB GB)\"\n        \n        if ($percentFree -lt 10) {\n            Write-Warning \"Low disk space on $($disk.DeviceID)!\"\n        }\n    }\n    \n    # Process count\n    $processes = Get-Process | Measure-Object\n    Write-Host \"Running Processes: $($processes.Count)\"\n    \n    # Network connections\n    $connections = Get-NetTCPConnection -State Established | Measure-Object\n    Write-Host \"Active Connections: $($connections.Count)\"\n    \n    # Uptime\n    $bootTime = (Get-CimInstance -ClassName Win32_OperatingSystem).LastBootUpTime\n    $uptime = (Get-Date) - $bootTime\n    Write-Host \"System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\"\n    \n} catch {\n    Write-Error \"Monitoring failed: $_\"\n    exit 1\n}"
    },
    
    {
      "id": "net-scan-002",
      "name": "Network Port Scanner",
      "description": "Scan network for open ports and services",
      "category": "network",
      "platform": "all",
      "requires_admin": true,
      "tags": ["network", "security", "scanning"],
      "version": "1.0.3",
      "author": "Security Team",
      "dependencies": [],
      "code": "# Network Port Scanner\n# Use {{TARGET_IP}} and {{PORT_RANGE}} as variables\n# Example: {{TARGET_IP}}=192.168.1.1, {{PORT_RANGE}}=1-1000\n\nparam(\n    [string]$target = \"{{TARGET_IP}}\",\n    [string]$portRange = \"{{PORT_RANGE}}\"\n)\n\nWrite-Host \"Scanning $target for open ports...\"\n\n# Parse port range\nif ($portRange -match \"(\\d+)-(\\d+)\") {\n    $startPort = [int]$matches[1]\n    $endPort = [int]$matches[2]\n} else {\n    $startPort = 1\n    $endPort = 1024\n}\n\n$openPorts = @()\n\nfor ($port = $startPort; $port -le $endPort; $port++) {\n    $tcpClient = New-Object System.Net.Sockets.TcpClient\n    $tcpClient.SendTimeout = 1000\n    $tcpClient.ReceiveTimeout = 1000\n    \n    try {\n        $asyncResult = $tcpClient.BeginConnect($target, $port, $null, $null)\n        $wait = $asyncResult.AsyncWaitHandle.WaitOne(500, $false)\n        \n        if ($wait -and $tcpClient.Connected) {\n            $tcpClient.EndConnect($asyncResult)\n            $openPorts += $port\n            Write-Host \"Port $port : OPEN\" -ForegroundColor Green\n            $tcpClient.Close()\n        } else {\n            Write-Host \"Port $port : CLOSED\" -ForegroundColor Gray\n        }\n    } catch {\n        Write-Host \"Port $port : FILTERED/ERROR\" -ForegroundColor Yellow\n    }\n}\n\nWrite-Host \"\\nScan Complete!\" -ForegroundColor Cyan\nWrite-Host \"Open ports on $target : $($openPorts -join ', ')\""
    },
    
    {
      "id": "sec-audit-003",
      "name": "Security Audit Tool",
      "description": "Basic security audit for Windows/Linux systems",
      "category": "security",
      "platform": "all",
      "requires_admin": true,
      "tags": ["security", "audit", "compliance"],
      "version": "2.1.0",
      "author": "CIS Security",
      "dependencies": [],
      "code": "#!/bin/bash\n# Security Audit Script\n# Use {{AUDIT_LEVEL}}=basic|detailed|full\n\nAUDIT_LEVEL=\"{{AUDIT_LEVEL:-basic}}\"\nREPORT_FILE=\"/tmp/security_audit_$(date +%Y%m%d_%H%M%S).txt\"\n\necho \"=== Security Audit Report ===\" | tee \"$REPORT_FILE\"\necho \"Date: $(date)\" | tee -a \"$REPORT_FILE\"\necho \"Hostname: $(hostname)\" | tee -a \"$REPORT_FILE\"\necho \"Audit Level: $AUDIT_LEVEL\" | tee -a \"$REPORT_FILE\"\necho \"\" | tee -a \"$REPORT_FILE\"\n\n# Check for root/admin privileges\nif [[ $EUID -eq 0 ]]; then\n    echo \"[âœ“] Running with administrative privileges\" | tee -a \"$REPORT_FILE\"\nelse\n    echo \"[!] Running without administrative privileges\" | tee -a \"$REPORT_FILE\"\nfi\n\n# System Information\necho \"\\n=== SYSTEM INFORMATION ===\" | tee -a \"$REPORT_FILE\"\nuname -a | tee -a \"$REPORT_FILE\"\n\n# User Accounts\necho \"\\n=== USER ACCOUNTS ===\" | tee -a \"$REPORT_FILE\"\ngrep -E '^[^:]*:[^:]*:0:' /etc/passwd | tee -a \"$REPORT_FILE\"\n\n# SSH Configuration\nif [ -f /etc/ssh/sshd_config ]; then\n    echo \"\\n=== SSH CONFIGURATION ===\" | tee -a \"$REPORT_FILE\"\n    grep -E \"^(PermitRootLogin|PasswordAuthentication|Protocol)\" /etc/ssh/sshd_config | tee -a \"$REPORT_FILE\"\nfi\n\n# Firewall Status\necho \"\\n=== FIREWALL STATUS ===\" | tee -a \"$REPORT_FILE\"\nif command -v ufw &> /dev/null; then\n    ufw status verbose | tee -a \"$REPORT_FILE\"\nelif command -v firewall-cmd &> /dev/null; then\n    firewall-cmd --state | tee -a \"$REPORT_FILE\"\nelse\n    echo \"No firewall manager found\" | tee -a \"$REPORT_FILE\"\nfi\n\n# Listening Ports\necho \"\\n=== LISTENING PORTS ===\" | tee -a \"$REPORT_FILE\"\nss -tuln | head -20 | tee -a \"$REPORT_FILE\"\n\n# Scheduled Tasks/Cron Jobs\necho \"\\n=== SCHEDULED TASKS ===\" | tee -a \"$REPORT_FILE\"\nif command -v crontab &> /dev/null; then\n    echo \"User crontabs:\" | tee -a \"$REPORT_FILE\"\n    for user in $(cut -f1 -d: /etc/passwd); do\n        crontab -u \"$user\" -l 2>/dev/null | grep -v \"^#\" | while read line; do\n            if [ ! -z \"$line\" ]; then\n                echo \"$user: $line\" | tee -a \"$REPORT_FILE\"\n            fi\n        done\n    done\nfi\n\n# SUID/SGID Files (if detailed audit)\nif [[ \"$AUDIT_LEVEL\" == \"detailed\" || \"$AUDIT_LEVEL\" == \"full\" ]]; then\n    echo \"\\n=== SUID/SGID FILES ===\" | tee -a \"$REPORT_FILE\"\n    find / -type f \\( -perm -4000 -o -perm -2000 \\) 2>/dev/null | head -30 | tee -a \"$REPORT_FILE\"\nfi\n\necho \"\\n=== AUDIT COMPLETE ===\" | tee -a \"$REPORT_FILE\"\necho \"Report saved to: $REPORT_FILE\" | tee -a \"$REPORT_FILE\""
    },
    
    {
      "id": "prod-backup-004",
      "name": "Automated Backup System",
      "description": "Intelligent backup script with compression and rotation",
      "category": "productivity",
      "platform": "all",
      "requires_admin": true,
      "tags": ["backup", "compression", "scheduler"],
      "version": "1.5.2",
      "author": "DevOps Team",
      "dependencies": ["7zip"],
      "code": "# Automated Backup System\n# Variables: {{BACKUP_SOURCE}}, {{BACKUP_DEST}}, {{RETENTION_DAYS}}\n\nparam(\n    [string]$Source = \"{{BACKUP_SOURCE}}\",\n    [string]$Destination = \"{{BACKUP_DEST}}\",\n    [int]$RetentionDays = {{RETENTION_DAYS}}\n)\n\n$ErrorActionPreference = \"Stop\"\n$timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n$backupName = \"backup_$timestamp.zip\"\n$backupPath = Join-Path $Destination $backupName\n\nfunction Test-Admin {\n    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()\n    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)\n    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n}\n\nif (-not (Test-Admin)) {\n    Write-Error \"This script requires administrative privileges\"\n    exit 1\n}\n\nWrite-Host \"Starting backup process...\" -ForegroundColor Cyan\nWrite-Host \"Source: $Source\"\nWrite-Host \"Destination: $backupPath\"\nWrite-Host \"Retention: $RetentionDays days\"\n\n# Check if source exists\nif (-not (Test-Path $Source)) {\n    Write-Error \"Source path does not exist: $Source\"\n    exit 1\n}\n\n# Create destination if it doesn't exist\nif (-not (Test-Path $Destination)) {\n    Write-Host \"Creating destination directory: $Destination\"\n    New-Item -ItemType Directory -Path $Destination -Force | Out-Null\n}\n\n# Calculate backup size\n$sourceSize = (Get-ChildItem $Source -Recurse | Measure-Object -Property Length -Sum).Sum\n$sourceSizeGB = [math]::Round($sourceSize / 1GB, 2)\nWrite-Host \"Estimated size: $sourceSizeGB GB\"\n\n# Create backup using Compress-Archive\ntry {\n    Write-Host \"Compressing files...\" -ForegroundColor Yellow\n    Compress-Archive -Path $Source -DestinationPath $backupPath -CompressionLevel Optimal\n    \n    $backupSize = (Get-Item $backupPath).Length\n    $backupSizeGB = [math]::Round($backupSize / 1GB, 2)\n    $compressionRatio = [math]::Round(($sourceSize - $backupSize) / $sourceSize * 100, 2)\n    \n    Write-Host \"Backup created successfully!\" -ForegroundColor Green\n    Write-Host \"Backup size: $backupSizeGB GB\"\n    Write-Host \"Compression ratio: $compressionRatio%\"\n    \n} catch {\n    Write-Error \"Backup failed: $_\"\n    exit 1\n}\n\n# Cleanup old backups\nWrite-Host \"\\nCleaning up old backups...\" -ForegroundColor Yellow\n$cutoffDate = (Get-Date).AddDays(-$RetentionDays)\n$oldBackups = Get-ChildItem $Destination -Filter \"backup_*.zip\" | \n    Where-Object { $_.LastWriteTime -lt $cutoffDate }\n\nif ($oldBackups.Count -gt 0) {\n    $totalFreed = ($oldBackups | Measure-Object -Property Length -Sum).Sum\n    $totalFreedGB = [math]::Round($totalFreed / 1GB, 2)\n    \n    $oldBackups | Remove-Item -Force\n    Write-Host \"Removed $($oldBackups.Count) old backups, freed $totalFreedGB GB\" -ForegroundColor Green\n} else {\n    Write-Host \"No old backups to remove\"\n}\n\n# Generate report\n$reportPath = Join-Path $Destination \"backup_report_$timestamp.txt\"\n@\"\nBackup Report\n=============\nDate: $(Get-Date)\nSource: $Source\nBackup: $backupName\nSize: $backupSizeGB GB\nCompression: $compressionRatio%\nRetention Policy: $RetentionDays days\nOld Backups Removed: $($oldBackups.Count)\nSpace Freed: $totalFreedGB GB\n\"@ | Out-File $reportPath\n\nWrite-Host \"\\nBackup completed successfully!\" -ForegroundColor Green\nWrite-Host \"Report: $reportPath\""
    },
    
    {
      "id": "dev-cleanup-005",
      "name": "Development Workspace Cleaner",
      "description": "Clean development directories, node_modules, build artifacts",
      "category": "development",
      "platform": "all",
      "requires_admin": false,
      "tags": ["development", "cleanup", "optimization"],
      "version": "1.0.1",
      "author": "Dev Tools Team",
      "dependencies": [],
      "code": "# Development Workspace Cleaner\n# Use {{WORKSPACE_PATH}} and {{PATTERNS}} variables\n\n$workspace = \"{{WORKSPACE_PATH}}\"\n$patterns = @(\"{{PATTERNS}}\".Split(','))\n$defaultPatterns = @(\n    \"node_modules\",\n    \"dist\",\n    \"build\",\n    \".gradle\",\n    \".idea\",\n    \".vs\",\n    \"bin\",\n    \"obj\",\n    \"__pycache__\",\n    \"*.log\",\n    \"*.tmp\",\n    \"*.temp\"\n)\n\nif ($patterns.Count -eq 1 -and [string]::IsNullOrEmpty($patterns[0])) {\n    $patterns = $defaultPatterns\n}\n\nif (-not (Test-Path $workspace)) {\n    Write-Error \"Workspace path does not exist: $workspace\"\n    exit 1\n}\n\nWrite-Host \"Cleaning development workspace: $workspace\" -ForegroundColor Cyan\nWrite-Host \"Patterns to remove: $($patterns -join ', ')\"\n\n$totalFreed = 0\n$itemsRemoved = 0\n\nforeach ($pattern in $patterns) {\n    Write-Host \"\\nLooking for: $pattern\" -ForegroundColor Yellow\n    \n    $items = Get-ChildItem -Path $workspace -Recurse -Force -Include $pattern -ErrorAction SilentlyContinue\n    \n    if ($items.Count -gt 0) {\n        Write-Host \"Found $($items.Count) items matching '$pattern'\"\n        \n        foreach ($item in $items) {\n            try {\n                if ($item.PSIsContainer) {\n                    $size = (Get-ChildItem $item.FullName -Recurse -Force -ErrorAction SilentlyContinue | \n                            Measure-Object -Property Length -Sum).Sum\n                    Remove-Item $item.FullName -Recurse -Force -ErrorAction Stop\n                } else {\n                    $size = $item.Length\n                    Remove-Item $item.FullName -Force -ErrorAction Stop\n                }\n                \n                $totalFreed += $size\n                $itemsRemoved++\n                Write-Host \"  Removed: $($item.FullName)\" -ForegroundColor Gray\n                \n            } catch {\n                Write-Host \"  Skipped (in use): $($item.FullName)\" -ForegroundColor Yellow\n            }\n        }\n    } else {\n        Write-Host \"No items found for pattern: $pattern\"\n    }\n}\n\n$totalFreedGB = [math]::Round($totalFreed / 1GB, 2)\n\nWrite-Host \"\\n\" + \"=\"*50 -ForegroundColor Cyan\nWrite-Host \"CLEANUP COMPLETE!\" -ForegroundColor Green\nWrite-Host \"Items removed: $itemsRemoved\"\nWrite-Host \"Space freed: $totalFreedGB GB\" -ForegroundColor Green\nWrite-Host \"=\"*50 -ForegroundColor Cyan"
    },
    
    {
      "id": "win-optimize-006",
      "name": "Windows Performance Optimizer",
      "description": "Optimize Windows performance with cleanup and tuning",
      "category": "system",
      "platform": "windows",
      "requires_admin": true,
      "tags": ["windows", "optimization", "performance"],
      "version": "2.0.0",
      "author": "Windows Optimization Team",
      "dependencies": [],
      "code": "# Windows Performance Optimizer\n# Requires administrative privileges\n\n$ErrorActionPreference = \"Stop\"\n\nfunction Show-Progress {\n    param($Activity, $Status)\n    Write-Progress -Activity $Activity -Status $Status\n    Start-Sleep -Milliseconds 100\n    Write-Progress -Activity $Activity -Status $Status -Completed\n}\n\nWrite-Host \"=== Windows Performance Optimizer ===\" -ForegroundColor Cyan\nWrite-Host \"Starting optimization process...\"\n\n# 1. Clean temporary files\nShow-Progress -Activity \"Optimization\" -Status \"Cleaning temporary files...\"\nWrite-Host \"\\n1. Cleaning temporary files...\" -ForegroundColor Yellow\n\n$tempPaths = @(\n    \"$env:TEMP\\*\",\n    \"C:\\Windows\\Temp\\*\",\n    \"$env:LOCALAPPDATA\\Temp\\*\"\n)\n\nforeach ($path in $tempPaths) {\n    if (Test-Path $path) {\n        Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue\n        Write-Host \"  Cleaned: $path\"\n    }\n}\n\n# 2. Clear Windows Update cache\nShow-Progress -Activity \"Optimization\" -Status \"Clearing Windows Update cache...\"\nWrite-Host \"\\n2. Clearing Windows Update cache...\" -ForegroundColor Yellow\nStop-Service wuauserv -Force -ErrorAction SilentlyContinue\nRemove-Item \"C:\\Windows\\SoftwareDistribution\\*\" -Recurse -Force -ErrorAction SilentlyContinue\nStart-Service wuauserv -ErrorAction SilentlyContinue\nWrite-Host \"  Windows Update cache cleared\"\n\n# 3. Clear DNS cache\nShow-Progress -Activity \"Optimization\" -Status \"Flushing DNS cache...\"\nWrite-Host \"\\n3. Flushing DNS cache...\" -ForegroundColor Yellow\nipconfig /flushdns\nWrite-Host \"  DNS cache flushed\"\n\n# 4. Clean Windows logs\nShow-Progress -Activity \"Optimization\" -Status \"Cleaning event logs...\"\nWrite-Host \"\\n4. Cleaning event logs...\" -ForegroundColor Yellow\nwevtutil el | ForEach-Object {\n    wevtutil cl $_\n}\nWrite-Host \"  Event logs cleared\"\n\n# 5. Optimize drives\nShow-Progress -Activity \"Optimization\" -Status \"Optimizing drives...\"\nWrite-Host \"\\n5. Optimizing drives...\" -ForegroundColor Yellow\nOptimize-Volume -DriveLetter C -Verbose\nWrite-Host \"  Drive optimization complete\"\n\n# 6. Disable unnecessary services\nShow-Progress -Activity \"Optimization\" -Status \"Optimizing services...\"\nWrite-Host \"\\n6. Optimizing services...\" -ForegroundColor Yellow\n\n$servicesToDisable = @(\n    \"HomeGroupListener\",\n    \"HomeGroupProvider\",\n    \"RemoteRegistry\"\n)\n\nforeach ($service in $servicesToDisable) {\n    $svc = Get-Service -Name $service -ErrorAction SilentlyContinue\n    if ($svc -and $svc.Status -eq \"Running\") {\n        Stop-Service $service -Force\n        Set-Service $service -StartupType Disabled\n        Write-Host \"  Disabled: $service\"\n    }\n}\n\n# 7. Clear thumbnail cache\nShow-Progress -Activity \"Optimization\" -Status \"Clearing thumbnail cache...\"\nWrite-Host \"\\n7. Clearing thumbnail cache...\" -ForegroundColor Yellow\nRemove-Item \"$env:LOCALAPPDATA\\Microsoft\\Windows\\Explorer\\thumbcache_*.db\" -Force -ErrorAction SilentlyContinue\nWrite-Host \"  Thumbnail cache cleared\"\n\n# 8. Reset Windows Search\nShow-Progress -Activity \"Optimization\" -Status \"Resetting Windows Search...\"\nWrite-Host \"\\n8. Resetting Windows Search...\" -ForegroundColor Yellow\nStop-Service \"WSearch\" -Force -ErrorAction SilentlyContinue\nRemove-Item \"C:\\ProgramData\\Microsoft\\Search\\Data\\*\" -Recurse -Force -ErrorAction SilentlyContinue\nStart-Service \"WSearch\" -ErrorAction SilentlyContinue\nWrite-Host \"  Windows Search reset\"\n\n# Calculate disk space freed\nShow-Progress -Activity \"Optimization\" -Status \"Calculating results...\"\n$freedSpace = Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\" | \n    Select-Object @{Name=\"Freed\";Expression={($_.Size - $_.FreeSpace)/1GB}}\n\nWrite-Host \"\\n\" + \"=\"*50 -ForegroundColor Green\nWrite-Host \"OPTIMIZATION COMPLETE!\" -ForegroundColor Green\nWrite-Host \"Estimated space freed: $([math]::Round($freedSpace.Freed, 2)) GB\" -ForegroundColor Green\nWrite-Host \"=\"*50 -ForegroundColor Green\n\nWrite-Host \"\\nRecommendation: Restart your computer for changes to take full effect.\" -ForegroundColor Yellow"
    },
    
    {
      "id": "linux-update-007",
      "name": "Linux System Updater",
      "description": "Automated system update and package management for Linux",
      "category": "system",
      "platform": "linux",
      "requires_admin": true,
      "tags": ["linux", "update", "security"],
      "version": "1.3.0",
      "author": "Linux Admin Team",
      "dependencies": [],
      "code": "#!/bin/bash\n# Linux System Updater\n# Variables: {{UPDATE_TYPE}}=security|all, {{AUTO_REBOOT}}=true|false\n\nUPDATE_TYPE=\"{{UPDATE_TYPE:-security}}\"\nAUTO_REBOOT=\"{{AUTO_REBOOT:-false}}\"\nLOG_FILE=\"/var/log/system_update_$(date +%Y%m%d_%H%M%S).log\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\n# Log function\nlog() {\n    echo -e \"$1\" | tee -a \"$LOG_FILE\"\n}\n\n# Check if running as root\nif [[ $EUID -ne 0 ]]; then\n    log \"${RED}This script must be run as root (use sudo)${NC}\"\n    exit 1\nfi\n\nlog \"${GREEN}=== Linux System Updater ===${NC}\"\nlog \"Date: $(date)\"\nlog \"Update Type: $UPDATE_TYPE\"\nlog \"Auto Reboot: $AUTO_REBOOT\"\nlog \"Log File: $LOG_FILE\"\n\n# Detect distribution\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    DISTRO=\"$ID\"\n    VERSION=\"$VERSION_ID\"\n    log \"Detected: $DISTRO $VERSION\"\nelse\n    log \"${RED}Unable to detect Linux distribution${NC}\"\n    exit 1\nfi\n\n# System information before update\nlog \"\\n${YELLOW}=== System Information ===${NC}\"\nlog \"Hostname: $(hostname)\"\nlog \"Kernel: $(uname -r)\"\nlog \"Uptime: $(uptime -p)\"\n\n# Disk space check\nlog \"\\n${YELLOW}=== Disk Space ===${NC}\"\ndf -h / | tee -a \"$LOG_FILE\"\n\n# Memory check\nlog \"\\n${YELLOW}=== Memory Usage ===${NC}\"\nfree -h | tee -a \"$LOG_FILE\"\n\n# Check if updates are available\nlog \"\\n${YELLOW}=== Checking for Updates ===${NC}\"\n\ncase $DISTRO in\n    ubuntu|debian)\n        apt-get update 2>&1 | tee -a \"$LOG_FILE\"\n        if [ \"$UPDATE_TYPE\" = \"security\" ]; then\n            UPDATES=$(apt-get upgrade --dry-run | grep -c \"^Inst\")\n            SEC_UPDATES=$(apt-get upgrade --dry-run | grep -i security | grep -c \"^Inst\")\n            log \"Available updates: $UPDATES\"\n            log \"Security updates: $SEC_UPDATES\"\n        else\n            UPDATES=$(apt-get dist-upgrade --dry-run | grep -c \"^Inst\")\n            log \"Available updates: $UPDATES\"\n        fi\n        ;;\n    centos|rhel|fedora)\n        if command -v dnf &> /dev/null; then\n            dnf check-update 2>&1 | tee -a \"$LOG_FILE\"\n            UPDATES=$(dnf check-update | grep -c \"^[a-zA-Z]\")\n        else\n            yum check-update 2>&1 | tee -a \"$LOG_FILE\"\n            UPDATES=$(yum check-update | grep -c \"^[a-zA-Z]\")\n        fi\n        log \"Available updates: $UPDATES\"\n        ;;\n    *)\n        log \"${RED}Unsupported distribution: $DISTRO${NC}\"\n        exit 1\n        ;;\nesac\n\nif [ \"$UPDATES\" -eq 0 ]; then\n    log \"${GREEN}System is up to date!${NC}\"\n    exit 0\nfi\n\n# Ask for confirmation\nif [ \"$UPDATE_TYPE\" = \"all\" ]; then\n    log \"\\n${YELLOW}WARNING: This will install ALL available updates${NC}\"\n    log \"Press Ctrl+C to cancel or wait 10 seconds to continue...\"\n    sleep 10\nfi\n\n# Perform update\nlog \"\\n${YELLOW}=== Performing Update ===${NC}\"\n\ncase $DISTRO in\n    ubuntu|debian)\n        if [ \"$UPDATE_TYPE\" = \"security\" ]; then\n            apt-get upgrade -y --only-upgrade 2>&1 | tee -a \"$LOG_FILE\"\n        else\n            apt-get dist-upgrade -y 2>&1 | tee -a \"$LOG_FILE\"\n        fi\n        apt-get autoremove -y 2>&1 | tee -a \"$LOG_FILE\"\n        apt-get clean 2>&1 | tee -a \"$LOG_FILE\"\n        ;;\n    centos|rhel|fedora)\n        if command -v dnf &> /dev/null; then\n            dnf upgrade -y 2>&1 | tee -a \"$LOG_FILE\"\n            dnf autoremove -y 2>&1 | tee -a \"$LOG_FILE\"\n            dnf clean all 2>&1 | tee -a \"$LOG_FILE\"\n        else\n            yum upgrade -y 2>&1 | tee -a \"$LOG_FILE\"\n            yum clean all 2>&1 | tee -a \"$LOG_FILE\"\n        fi\n        ;;\nesac\n\n# Clean package cache\nlog \"\\n${YELLOW}=== Cleaning Package Cache ===${NC}\"\ncase $DISTRO in\n    ubuntu|debian)\n        apt-get autoclean 2>&1 | tee -a \"$LOG_FILE\"\n        ;;\n    centos|rhel|fedora)\n        if command -v dnf &> /dev/null; then\n            dnf clean packages 2>&1 | tee -a \"$LOG_FILE\"\n        else\n            yum clean packages 2>&1 | tee -a \"$LOG_FILE\"\n        fi\n        ;;\nesac\n\n# Check if reboot is required\nREBOOT_REQUIRED=false\nif [ -f /var/run/reboot-required ]; then\n    REBOOT_REQUIRED=true\n    log \"${YELLOW}\\nSystem reboot required!${NC}\"\nfi\n\n# Update complete\nlog \"\\n${GREEN}=== Update Complete ===${NC}\"\nlog \"Updates installed: $UPDATES\"\nlog \"Reboot required: $REBOOT_REQUIRED\"\n\n# Handle reboot\nif [ \"$REBOOT_REQUIRED\" = true ]; then\n    if [ \"$AUTO_REBOOT\" = true ]; then\n        log \"${YELLOW}System will reboot in 60 seconds...${NC}\"\n        log \"Press Ctrl+C to cancel\"\n        sleep 60\n        reboot\n    else\n        log \"${YELLOW}Please reboot the system to complete the update process${NC}\"\n    fi\nfi\n\nlog \"\\nUpdate log saved to: $LOG_FILE\""
    },
    
    {
      "id": "file-organizer-008",
      "name": "Smart File Organizer",
      "description": "Automatically organize files by type, date, or category",
      "category": "productivity",
      "platform": "all",
      "requires_admin": false,
      "tags": ["files", "organization", "automation"],
      "version": "1.2.0",
      "author": "Productivity Tools",
      "dependencies": [],
      "code": "# Smart File Organizer\n# Variables: {{ORGANIZE_BY}}=type|date|size, {{SOURCE_DIR}}, {{DEST_DIR}}\n\nparam(\n    [string]$OrganizeBy = \"{{ORGANIZE_BY}}\",\n    [string]$SourceDir = \"{{SOURCE_DIR}}\",\n    [string]$DestDir = \"{{DEST_DIR}}\"\n)\n\nif (-not (Test-Path $SourceDir)) {\n    Write-Error \"Source directory does not exist: $SourceDir\"\n    exit 1\n}\n\nif (-not (Test-Path $DestDir)) {\n    Write-Host \"Creating destination directory: $DestDir\"\n    New-Item -ItemType Directory -Path $DestDir -Force | Out-Null\n}\n\nWrite-Host \"Smart File Organizer\" -ForegroundColor Cyan\nWrite-Host \"Source: $SourceDir\"\nWrite-Host \"Destination: $DestDir\"\nWrite-Host \"Organize by: $OrganizeBy\"\n\n# File type categories\n$fileCategories = @{\n    \"Images\" = @(\".jpg\", \".jpeg\", \".png\", \".gif\", \".bmp\", \".tiff\", \".svg\", \".webp\")\n    \"Documents\" = @(\".pdf\", \".doc\", \".docx\", \".txt\", \".rtf\", \".odt\", \".xls\", \".xlsx\", \".ppt\", \".pptx\")\n    \"Audio\" = @(\".mp3\", \".wav\", \".flac\", \".aac\", \".ogg\", \".wma\")\n    \"Video\" = @(\".mp4\", \".avi\", \".mkv\", \".mov\", \".wmv\", \".flv\", \".webm\")\n    \"Archives\" = @(\".zip\", \".rar\", \".7z\", \".tar\", \".gz\", \".bz2\")\n    \"Code\" = @(\".py\", \".js\", \".html\", \".css\", \".java\", \".cpp\", \".cs\", \".php\", \".rb\", \".go\", \".rs\")\n    \"Executables\" = @(\".exe\", \".msi\", \".bat\", \".sh\", \".app\", \".dmg\")\n}\n\n$files = Get-ChildItem -Path $SourceDir -File\n$totalFiles = $files.Count\n$organizedCount = 0\n\nWrite-Host \"Found $totalFiles files to organize\"\n\nforeach ($file in $files) {\n    try {\n        $destinationPath = $null\n        \n        switch ($OrganizeBy) {\n            \"type\" {\n                # Organize by file type/category\n                $category = \"Other\"\n                foreach ($cat in $fileCategories.Keys) {\n                    if ($fileCategories[$cat] -contains $file.Extension.ToLower()) {\n                        $category = $cat\n                        break\n                    }\n                }\n                \n                $destinationPath = Join-Path $DestDir $category\n            }\n            \n            \"date\" {\n                # Organize by creation date (YYYY-MM)\n                $dateFolder = $file.CreationTime.ToString(\"yyyy-MM\")\n                $destinationPath = Join-Path $DestDir $dateFolder\n            }\n            \n            \"size\" {\n                # Organize by file size\n                $sizeKB = [math]::Round($file.Length / 1KB)\n                \n                if ($sizeKB -lt 100) { $sizeCat = \"Tiny (<100KB)\" }\n                elseif ($sizeKB -lt 1024) { $sizeCat = \"Small (<1MB)\" }\n                elseif ($sizeKB -lt 10240) { $sizeCat = \"Medium (<10MB)\" }\n                elseif ($sizeKB -lt 102400) { $sizeCat = \"Large (<100MB)\" }\n                else { $sizeCat = \"Huge (>=100MB)\" }\n                \n                $destinationPath = Join-Path $DestDir $sizeCat\n            }\n            \n            default {\n                Write-Error \"Invalid organization method: $OrganizeBy\"\n                exit 1\n            }\n        }\n        \n        # Create destination folder if it doesn't exist\n        if (-not (Test-Path $destinationPath)) {\n            New-Item -ItemType Directory -Path $destinationPath -Force | Out-Null\n        }\n        \n        # Move the file\n        $newFilePath = Join-Path $destinationPath $file.Name\n        \n        # Handle duplicate filenames\n        $counter = 1\n        while (Test-Path $newFilePath) {\n            $nameWithoutExt = [System.IO.Path]::GetFileNameWithoutExtension($file.Name)\n            $ext = $file.Extension\n            $newFileName = \"${nameWithoutExt}_$counter$ext\"\n            $newFilePath = Join-Path $destinationPath $newFileName\n            $counter++\n        }\n        \n        Move-Item $file.FullName $newFilePath -Force\n        $organizedCount++\n        \n        Write-Host \"  Moved: $($file.Name) -> $([System.IO.Path]::GetFileName($destinationPath))/\" -ForegroundColor Gray\n        \n    } catch {\n        Write-Host \"  Error moving $($file.Name): $_\" -ForegroundColor Red\n    }\n}\n\n# Create summary\n$summaryFile = Join-Path $DestDir \"organization_summary_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt\"\n@\"\nFile Organization Summary\n=========================\nDate: $(Get-Date)\nSource Directory: $SourceDir\nDestination Directory: $DestDir\nOrganization Method: $OrganizeBy\nTotal Files Processed: $totalFiles\nSuccessfully Organized: $organizedCount\nFailed: $($totalFiles - $organizedCount)\n\nDirectory Structure Created:\n$((Get-ChildItem $DestDir -Directory | ForEach-Object { \"- $($_.Name) ($((Get-ChildItem $_.FullName -File).Count) files)\" }) -join \"\\n\")\n\"@ | Out-File $summaryFile\n\nWrite-Host \"\\n\" + \"=\"*50 -ForegroundColor Green\nWrite-Host \"ORGANIZATION COMPLETE!\" -ForegroundColor Green\nWrite-Host \"Files organized: $organizedCount/$totalFiles\" -ForegroundColor Green\nWrite-Host \"Summary saved to: $summaryFile\" -ForegroundColor Green\nWrite-Host \"=\"*50 -ForegroundColor Green"
    },
    
    {
      "id": "ssl-checker-009",
      "name": "SSL Certificate Checker",
      "description": "Check SSL certificates for domains and alert on expiration",
      "category": "security",
      "platform": "all",
      "requires_admin": false,
      "tags": ["ssl", "security", "monitoring"],
      "version": "1.1.0",
      "author": "Security Team",
      "dependencies": [],
      "code": "# SSL Certificate Checker\n# Variables: {{DOMAINS}}=comma-separated list, {{WARNING_DAYS}}=30\n\nparam(\n    [string]$Domains = \"{{DOMAINS}}\",\n    [int]$WarningDays = {{WARNING_DAYS}}\n)\n\n$ErrorActionPreference = \"Stop\"\n\nfunction Test-SSLCertificate {\n    param(\n        [string]$Domain,\n        [int]$Port = 443\n    )\n    \n    try {\n        $tcpClient = New-Object System.Net.Sockets.TcpClient\n        $tcpClient.Connect($Domain, $Port)\n        \n        $tcpStream = $tcpClient.GetStream()\n        $sslStream = New-Object System.Net.Security.SslStream($tcpStream, $false, {\n            param($sender, $certificate, $chain, $sslPolicyErrors)\n            return $true\n        })\n        \n        $sslStream.AuthenticateAsClient($Domain)\n        $certificate = $sslStream.RemoteCertificate\n        \n        $sslStream.Close()\n        $tcpClient.Close()\n        \n        return $certificate\n        \n    } catch {\n        Write-Warning \"Failed to connect to $Domain`:$Port - $_\"\n        return $null\n    }\n}\n\nfunction Get-CertificateInfo {\n    param(\n        [System.Security.Cryptography.X509Certificates.X509Certificate]$Certificate\n    )\n    \n    if (-not $Certificate) { return $null }\n    \n    $cert2 = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($Certificate)\n    \n    return [PSCustomObject]@{\n        Subject = $cert2.Subject\n        Issuer = $cert2.Issuer\n        NotBefore = $cert2.NotBefore\n        NotAfter = $cert2.NotAfter\n        Thumbprint = $cert2.Thumbprint\n        SerialNumber = $cert2.SerialNumber\n        DaysRemaining = ($cert2.NotAfter - (Get-Date)).Days\n        Algorithm = $cert2.SignatureAlgorithm.FriendlyName\n        KeySize = if ($cert2.PublicKey.Key -is [System.Security.Cryptography.RSACryptoServiceProvider]) {\n            $cert2.PublicKey.Key.KeySize\n        } else { \"N/A\" }\n    }\n}\n\nWrite-Host \"SSL Certificate Checker\" -ForegroundColor Cyan\nWrite-Host \"Warning Threshold: $WarningDays days\"\n\n$domainList = $Domains.Split(',') | ForEach-Object { $_.Trim() }\n$results = @()\n\nforeach ($domain in $domainList) {\n    Write-Host \"\\nChecking: $domain\" -ForegroundColor Yellow\n    \n    $cert = Test-SSLCertificate -Domain $domain\n    $info = Get-CertificateInfo -Certificate $cert\n    \n    if ($info) {\n        $results += $info\n        \n        $statusColor = if ($info.DaysRemaining -lt 0) {\n            \"Red\"\n        } elseif ($info.DaysRemaining -lt $WarningDays) {\n            \"Yellow\"\n        } else {\n            \"Green\"\n        }\n        \n        Write-Host \"  Subject: $($info.Subject)\" -ForegroundColor Gray\n        Write-Host \"  Issuer: $($info.Issuer)\" -ForegroundColor Gray\n        Write-Host \"  Valid From: $($info.NotBefore)\" -ForegroundColor Gray\n        Write-Host \"  Valid Until: $($info.NotAfter)\" -ForegroundColor Gray\n        Write-Host \"  Days Remaining: $($info.DaysRemaining)\" -ForegroundColor $statusColor\n        Write-Host \"  Algorithm: $($info.Algorithm)\" -ForegroundColor Gray\n        \n    } else {\n        Write-Host \"  Unable to retrieve certificate\" -ForegroundColor Red\n    }\n}\n\n# Generate report\n$report = @\"\nSSL Certificate Check Report\n============================\nGenerated: $(Get-Date)\nDomains Checked: $($domainList.Count)\nWarning Threshold: $WarningDays days\n\nResults:\n\"@\n\nforeach ($result in $results) {\n    $status = if ($result.DaysRemaining -lt 0) {\n        \"EXPIRED\"\n    } elseif ($result.DaysRemaining -lt $WarningDays) {\n        \"WARNING\"\n    } else {\n        \"OK\"\n    }\n    \n    $report += @\"\nDomain: $(($result.Subject -split '=')[1])\nStatus: $status\nValid Until: $($result.NotAfter)\nDays Remaining: $($result.DaysRemaining)\nIssuer: $($result.Issuer)\n---\n\"@\n}\n\n# Check for expiring certificates\n$expiring = $results | Where-Object { $_.DaysRemaining -lt $WarningDays }\nif ($expiring) {\n    $report += @\"\n\\nALERT: Expiring Certificates\n\"@\n    foreach ($cert in $expiring) {\n        $domainName = ($cert.Subject -split '=')[1]\n        $report += \"- $domainName expires in $($cert.DaysRemaining) days ($($cert.NotAfter))\\n\"\n    }\n}\n\n# Save report\n$reportFile = \"ssl_report_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt\"\n$report | Out-File $reportFile\n\nWrite-Host \"\\n\" + \"=\"*50 -ForegroundColor Cyan\nWrite-Host \"CHECK COMPLETE!\" -ForegroundColor Green\nWrite-Host \"Domains checked: $($domainList.Count)\" -ForegroundColor Green\nif ($expiring) {\n    Write-Host \"Expiring certificates found: $($expiring.Count)\" -ForegroundColor Red\n}\nWrite-Host \"Report saved to: $reportFile\" -ForegroundColor Green\nWrite-Host \"=\"*50 -ForegroundColor Cyan"
    },
    
    {
      "id": "git-cleaner-010",
      "name": "Git Repository Maintenance",
      "description": "Clean and optimize Git repositories, remove old branches",
      "category": "development",
      "platform": "all",
      "requires_admin": false,
      "tags": ["git", "development", "cleanup"],
      "version": "1.0.2",
      "author": "DevOps Team",
      "dependencies": ["git"],
      "code": "# Git Repository Maintenance\n# Variables: {{REPO_PATH}}, {{DAYS_OLD}}=30, {{REMOTE_NAME}}=origin\n\nparam(\n    [string]$RepoPath = \"{{REPO_PATH}}\",\n    [int]$DaysOld = {{DAYS_OLD}},\n    [string]$RemoteName = \"{{REMOTE_NAME}}\"\n)\n\nif (-not (Test-Path $RepoPath)) {\n    Write-Error \"Repository path does not exist: $RepoPath\"\n    exit 1\n}\n\n# Check if git is available\nif (-not (Get-Command git -ErrorAction SilentlyContinue)) {\n    Write-Error \"Git is not installed or not in PATH\"\n    exit 1\n}\n\nSet-Location $RepoPath\n\nWrite-Host \"Git Repository Maintenance\" -ForegroundColor Cyan\nWrite-Host \"Repository: $RepoPath\"\nWrite-Host \"Cleanup threshold: $DaysOld days\"\n\n# Get current branch\n$currentBranch = git branch --show-current\nWrite-Host \"Current branch: $currentBranch\"\n\n# 1. Fetch latest changes\nWrite-Host \"\\n1. Fetching latest changes...\" -ForegroundColor Yellow\ngit fetch --all --prune 2>&1 | Write-Host\n\n# 2. Clean merged branches\nWrite-Host \"\\n2. Cleaning merged branches...\" -ForegroundColor Yellow\n\n# Local branches that have been merged into current branch\n$mergedBranches = git branch --merged $currentBranch | \n    Where-Object { $_ -notmatch \"^[*\\s]*(master|main|develop|$currentBranch)$\" } |\n    ForEach-Object { $_.Trim() }\n\nif ($mergedBranches.Count -gt 0) {\n    Write-Host \"Found $($mergedBranches.Count) merged branches to delete:\"\n    foreach ($branch in $mergedBranches) {\n        Write-Host \"  Deleting: $branch\" -ForegroundColor Gray\n        git branch -d $branch 2>&1 | Write-Host\n    }\n} else {\n    Write-Host \"No merged branches to delete\"\n}\n\n# 3. Remove stale remote branches\nWrite-Host \"\\n3. Removing stale remote branches...\" -ForegroundColor Yellow\n\n$cutoffDate = (Get-Date).AddDays(-$DaysOld)\n$staleBranches = git branch -r --format=\"%(refname:short) %(committerdate:iso)\" | \n    ForEach-Object {\n        $parts = $_ -split \" \", 2\n        [PSCustomObject]@{\n            Branch = $parts[0]\n            Date = [datetime]::Parse($parts[1])\n        }\n    } | \n    Where-Object { \n        $_.Date -lt $cutoffDate -and \n        $_.Branch -match \"^$RemoteName/\" -and \n        $_.Branch -notmatch \"^$RemoteName/(master|main|develop|HEAD)$\"\n    }\n\nif ($staleBranches.Count -gt 0) {\n    Write-Host \"Found $($staleBranches.Count) stale remote branches older than $DaysOld days:\"\n    foreach ($branch in $staleBranches) {\n        $branchName = $branch.Branch.Replace(\"$RemoteName/\", \"\")\n        $daysAgo = [math]::Round(((Get-Date) - $branch.Date).TotalDays)\n        \n        Write-Host \"  Stale: $branchName ($daysAgo days old)\" -ForegroundColor Gray\n        \n        # Delete remote branch\n        git push $RemoteName --delete $branchName 2>&1 | Write-Host\n        \n        # Delete local tracking branch if exists\n        $localBranch = \"remotes/$RemoteName/$branchName\"\n        if (git branch -r | Select-String \"^\\s*$localBranch$\")) {\n            git branch -dr $localBranch 2>&1 | Write-Host\n        }\n    }\n} else {\n    Write-Host \"No stale remote branches found\"\n}\n\n# 4. Run garbage collection\nWrite-Host \"\\n4. Running garbage collection...\" -ForegroundColor Yellow\ngit gc --auto --prune=all 2>&1 | Write-Host\n\n# 5. Check repository size\nWrite-Host \"\\n5. Checking repository size...\" -ForegroundColor Yellow\ngit count-objects -vH 2>&1 | Write-Host\n\n# 6. Check for large files\nWrite-Host \"\\n6. Checking for large files...\" -ForegroundColor Yellow\ngit rev-list --objects --all | \\\n    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \\\n    Select-String \"^blob\" | \\\n    ForEach-Object { \n        $parts = $_ -split \" \"\n        [PSCustomObject]@{\n            Size = [int]$parts[2]\n            Hash = $parts[1]\n            Path = $parts[3..($parts.Length-1)] -join \" \"\n        }\n    } | \\\n    Sort-Object Size -Descending | \\\n    Select-Object -First 10 | \\\n    ForEach-Object {\n        $sizeMB = [math]::Round($_.Size / 1MB, 2)\n        Write-Host \"  $sizeMB MB - $($_.Path)\" -ForegroundColor Gray\n    }\n\n# 7. Update submodules\nif (Test-Path \".gitmodules\") {\n    Write-Host \"\\n7. Updating submodules...\" -ForegroundColor Yellow\ngit submodule update --init --recursive 2>&1 | Write-Host\n}\n\nWrite-Host \"\\n\" + \"=\"*50 -ForegroundColor Green\nWrite-Host \"MAINTENANCE COMPLETE!\" -ForegroundColor Green\nWrite-Host \"Repository: $(Resolve-Path $RepoPath)\" -ForegroundColor Green\nWrite-Host \"=\"*50 -ForegroundColor Green"
    }
  ],
  
  "templates": [
    {
      "id": "template-basic",
      "name": "Basic Script Template",
      "description": "Template with error handling and logging",
      "platform": "all",
      "code": "# {{SCRIPT_NAME}}\n# Description: {{SCRIPT_DESCRIPTION}}\n# Author: {{AUTHOR}}\n# Version: {{VERSION}}\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$LogFile = \"{{LOG_PATH}}\"\n)\n\n$ErrorActionPreference = \"Stop\"\n$WarningPreference = \"Continue\"\n\nfunction Write-Log {\n    param([string]$Message, [string]$Level = \"INFO\")\n    \n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $logMessage = \"[$timestamp] [$Level] $Message\"\n    \n    # Write to console with color\n    switch ($Level) {\n        \"ERROR\" { Write-Host $logMessage -ForegroundColor Red }\n        \"WARN\" { Write-Host $logMessage -ForegroundColor Yellow }\n        \"INFO\" { Write-Host $logMessage -ForegroundColor Cyan }\n        default { Write-Host $logMessage }\n    }\n    \n    # Write to log file\n    if ($LogFile) {\n        Add-Content -Path $LogFile -Value $logMessage -Encoding UTF8\n    }\n}\n\nfunction Test-Requirements {\n    # Check script requirements here\n    Write-Log \"Checking requirements...\" \"INFO\"\n    \n    # Example: Check for admin privileges\n    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent())\n        .IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)\n    \n    if (-not $isAdmin) {\n        Write-Log \"Script requires administrative privileges\" \"WARN\"\n    }\n    \n    return $true\n}\n\nfunction Main {\n    try {\n        Write-Log \"Starting {{SCRIPT_NAME}}\" \"INFO\"\n        \n        # Check requirements\n        if (-not (Test-Requirements)) {\n            Write-Log \"Requirements not met\" \"ERROR\"\n            exit 1\n        }\n        \n        # Main script logic here\n        Write-Log \"Processing...\" \"INFO\"\n        \n        # TODO: Add your script logic here\n        \n        Write-Log \"Script completed successfully\" \"INFO\"\n        \n    } catch {\n        Write-Log \"Script failed: $_\" \"ERROR\"\n        Write-Log \"Stack trace: $($_.ScriptStackTrace)\" \"ERROR\"\n        exit 1\n    }\n}\n\n# Entry point\nMain"
    },
    
    {
      "id": "template-advanced",
      "name": "Advanced Script Template",
      "description": "Template with configuration, retry logic, and notifications",
      "platform": "all",
      "code": "# {{SCRIPT_NAME}}\n# Advanced script template with retry logic and notifications\n\n# Configuration\n$Config = @{\n    MaxRetries = 3\n    RetryDelay = 5  # seconds\n    LogFile = \"{{LOG_PATH}}\"\n    NotificationEmail = \"{{ADMIN_EMAIL}}\"\n    TimeoutSeconds = 30\n}\n\n# Initialize\n$ErrorActionPreference = \"Stop\"\n$ScriptStartTime = Get-Date\n\n# Functions\nfunction Write-Log {\n    param([string]$Message, [string]$Level = \"INFO\")\n    \n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\n    $logMessage = \"[$timestamp] [$Level] $Message\"\n    \n    # Console output with colors\n    $colors = @{\n        \"ERROR\" = \"Red\"\n        \"WARN\" = \"Yellow\"\n        \"INFO\" = \"Cyan\"\n        \"DEBUG\" = \"Gray\"\n        \"SUCCESS\" = \"Green\"\n    }\n    \n    if ($colors.ContainsKey($Level)) {\n        Write-Host $logMessage -ForegroundColor $colors[$Level]\n    } else {\n        Write-Host $logMessage\n    }\n    \n    # File logging\n    if ($Config.LogFile) {\n        Add-Content -Path $Config.LogFile -Value $logMessage -Encoding UTF8 -Force\n    }\n}\n\nfunction Invoke-WithRetry {\n    param(\n        [scriptblock]$ScriptBlock,\n        [int]$MaxRetries = $Config.MaxRetries,\n        [int]$RetryDelay = $Config.RetryDelay\n    )\n    \n    $attempt = 1\n    $lastError = $null\n    \n    while ($attempt -le $MaxRetries) {\n        try {\n            Write-Log \"Attempt $attempt of $MaxRetries\" \"DEBUG\"\n            return & $ScriptBlock\n        } catch {\n            $lastError = $_\n            Write-Log \"Attempt $attempt failed: $_\" \"WARN\"\n            \n            if ($attempt -lt $MaxRetries) {\n                Write-Log \"Retrying in $RetryDelay seconds...\" \"DEBUG\"\n                Start-Sleep -Seconds $RetryDelay\n            }\n            $attempt++\n        }\n    }\n    \n    throw \"Failed after $MaxRetries attempts. Last error: $lastError\"\n}\n\nfunction Send-Notification {\n    param([string]$Subject, [string]$Body)\n    \n    if (-not $Config.NotificationEmail) {\n        Write-Log \"No notification email configured\" \"DEBUG\"\n        return\n    }\n    \n    try {\n        # Example: Send email via SMTP\n        # $smtp = New-Object Net.Mail.SmtpClient(\"smtp.example.com\", 587)\n        # $smtp.Send(\"sender@example.com\", $Config.NotificationEmail, $Subject, $Body)\n        \n        Write-Log \"Notification sent: $Subject\" \"INFO\"\n    } catch {\n        Write-Log \"Failed to send notification: $_\" \"WARN\"\n    }\n}\n\nfunction Get-PerformanceMetrics {\n    $metrics = @{\n        CPU = (Get-WmiObject Win32_Processor | Measure-Object -Property LoadPercentage -Average).Average\n        Memory = (Get-WmiObject Win32_OperatingSystem | \n            Select-Object @{\n                Name=\"UsedPercent\"; \n                Expression={[math]::Round((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory) / $_.TotalVisibleMemorySize) * 100, 2)}\n            }).UsedPercent\n        Disk = (Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\" | \n            Select-Object @{\n                Name=\"FreePercent\"; \n                Expression={[math]::Round(($_.FreeSpace / $_.Size) * 100, 2)}\n            }).FreePercent\n    }\n    \n    return $metrics\n}\n\nfunction Main {\n    try {\n        Write-Log \"=== Starting {{SCRIPT_NAME}} ===\" \"INFO\"\n        Write-Log \"Configuration: $(ConvertTo-Json $Config -Compress)\" \"DEBUG\"\n        \n        # Record performance metrics before execution\n        $startMetrics = Get-PerformanceMetrics\n        Write-Log \"Start metrics - CPU: $($startMetrics.CPU)%, Memory: $($startMetrics.Memory)%, Disk: $($startMetrics.Disk)% free\" \"DEBUG\"\n        \n        # Main execution with retry logic\n        $result = Invoke-WithRetry -ScriptBlock {\n            # TODO: Add your main script logic here\n            Write-Log \"Executing main logic...\" \"INFO\"\n            \n            # Simulate work\n            Start-Sleep -Seconds 2\n            \n            return \"Success\"\n        }\n        \n        # Record performance metrics after execution\n        $endMetrics = Get-PerformanceMetrics\n        Write-Log \"End metrics - CPU: $($endMetrics.CPU)%, Memory: $($endMetrics.Memory)%, Disk: $($endMetrics.Disk)% free\" \"DEBUG\"\n        \n        # Calculate execution time\n        $executionTime = (Get-Date) - $ScriptStartTime\n        Write-Log \"Execution completed in $($executionTime.TotalSeconds) seconds\" \"SUCCESS\"\n        \n        # Send success notification\n        Send-Notification -Subject \"{{SCRIPT_NAME}} Completed Successfully\" -Body \"Execution time: $($executionTime.TotalSeconds) seconds\"\n        \n        return $result\n        \n    } catch {\n        Write-Log \"Script execution failed: $_\" \"ERROR\"\n        Write-Log \"Stack trace: $($_.ScriptStackTrace)\" \"DEBUG\"\n        \n        # Send failure notification\n        Send-Notification -Subject \"{{SCRIPT_NAME}} Failed\" -Body \"Error: $_\"\n        \n        exit 1\n    }\n}\n\n# Entry point\nMain"
    }
  ],
  
  "documentation": {
    "variable_syntax": {
      "description": "Variables are enclosed in double curly braces {{VARIABLE_NAME}}",
      "examples": [
        "{{TARGET_IP}} - Will prompt user for IP address",
        "{{GLOBAL_VAR}} - Will use value from Global Settings",
        "{{USERNAME}} - Built-in variable for current user"
      ]
    },
    "platform_specific_notes": {
      "windows": "Use PowerShell syntax. Admin privileges required for system changes.",
      "linux": "Use Bash syntax. Scripts may require sudo privileges.",
      "all": "Scripts should be written to work on both platforms with conditional logic."
    },
    "best_practices": [
      "Always include error handling with try-catch blocks",
      "Use descriptive variable names",
      "Include comments for complex logic",
      "Test scripts in a safe environment first",
      "Consider security implications of automation"
    ]
  }
}
